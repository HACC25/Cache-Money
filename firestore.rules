rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }
    
    // Get the current user's data from Firestore (safely)
    function getUserData() {
      return isSignedIn() ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data : null;
    }
    
    // Get the current user's role from Firestore (safely)
    function getUserRole() {
      return isSignedIn() ? getUserData().role : null;
    }
    
    // Check if user is approved
    function isApproved() {
      let userData = getUserData();
      return isSignedIn() && (!userData.keys().hasAll(['approved']) || userData.approved == true);
    }
    
    // Check if user is ETS employee AND approved
    function isETSEmployee() {
      return isSignedIn() && getUserRole() == 'ets' && isApproved();
    }
    
    // Check if user is vendor AND approved
    function isVendor() {
      return isSignedIn() && getUserRole() == 'vendor' && isApproved();
    }
    
    // Check if user is public (public users don't need approval)
    function isPublic() {
      return isSignedIn() && getUserRole() == 'public';
    }
    
    // Check if user owns the resource
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Check if user is in admins collection
    function isAdminUser() {
      return isSignedIn() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    
    // Admins collection rules
    match /admins/{adminId} {
      // Users can read their own admin document (to check if they're admin)
      // Admins can read all admin documents
      allow read: if isSignedIn();
      
      // Only existing admins can create new admins
      allow create: if isAdminUser();
      
      // Only existing admins can update admin documents
      allow update: if isAdminUser();
      
      // Only existing admins can remove admin privileges
      allow delete: if isAdminUser();
    }
    
    // Users collection rules
    match /users/{userId} {
      // Users can read their own document
      // Allow reading any user document (needed for admin approval dashboard to query pending users)
      // ETS employees can read all user documents (to assign vendors)
      allow read: if isSignedIn();
      
      // Allow user creation during sign-up with approval fields
      allow create: if isOwner(userId) && 
                      request.resource.data.keys().hasAll(['email', 'role', 'createdAt', 'approved', 'approvalStatus']) &&
                      request.resource.data.role in ['public', 'vendor', 'ets'] &&
                      // Ensure ETS/vendor users are created as pending
                      ((request.resource.data.role in ['ets', 'vendor'] && request.resource.data.approved == false && request.resource.data.approvalStatus == 'pending') ||
                       (request.resource.data.role == 'public' && request.resource.data.approved == true && request.resource.data.approvalStatus == 'approved'));
      
      // Only admins can update approved and approvalStatus fields
      allow update: if isAdminUser() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['approved', 'approvalStatus']);
      
      // Users cannot delete their own account via Firestore
      allow delete: if false;
    }
    
    // Projects collection rules
    match /projects/{projectId} {
      // Anyone can read projects (public access)
      allow read: if true;
      
      // Only ETS employees can create new projects
      allow create: if isETSEmployee() &&
                      request.resource.data.keys().hasAll(['name', 'description', 'status', 'createdBy', 'createdAt']) &&
                      request.resource.data.createdBy == request.auth.uid;
      
      // Only ETS employees can update projects
      allow update: if isETSEmployee();
      
      // Only ETS employees can delete projects
      allow delete: if isETSEmployee();
      
      // Reports subcollection rules
      match /reports/{reportId} {
        // Anyone can read reports (public access)
        allow read: if true;
        
        // Only vendors can create new reports
        allow create: if isVendor() &&
                        request.resource.data.keys().hasAll(['month', 'summary', 'createdBy', 'createdAt']) &&
                        request.resource.data.createdBy == request.auth.uid;
        
        // Only vendors can update reports (optionally restrict to report owner)
        allow update: if isVendor();
        
        // Only vendors can delete reports (optionally restrict to report owner)
        allow delete: if isVendor();
      }
    }
    
    // Deny access to all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
